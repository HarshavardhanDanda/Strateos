import _ from 'lodash';

const formatRailsAttrErr = (field, err) => `Error: '${field}' ${err}`;

// Handle a response generated by a rails model that failed to validate
// For example, the server would render: { errors: MyModal.errors }
const fromRailsResource = (xhr) => {
  const errors = Object.keys(xhr.responseJSON).map((field) => {
    const errorTexts = xhr.responseJSON[field];
    if (Array.isArray(errorTexts)) {
      return errorTexts.map(str => formatRailsAttrErr(field, str));
    } else {
      return formatRailsAttrErr(field, errorTexts);
    }
  });
  return _.flatten(errors);
};

const fromJsonApi = (xhr) => {
  return xhr.responseJSON.errors.map((e) => {
    return e.detail || e.title || String(e);
  });
};

const isJsonApi = (xhr) => {
  const { errors } = xhr.responseJSON;
  return errors &&
    Array.isArray(errors) &&
    typeof errors[0] != 'string';
};

const fromXHR = (xhr, exception, text) => {
  const res = xhr.responseJSON;
  if (!res) {
    if (text) {
      return [text];
    } else if (exception) {
      return [exception];
    } else {
      return [xhr.status ? 'Error: ' + xhr.status : 'Connection error'];
    }
  }

  if (res.error_message) {
    return [res.error_message];
  } else if (res.message) {
    return [res.message];
  } else if (res.error) {
    return [res.error];
  } else if (res.errors) {
    if (isJsonApi(xhr)) {
      return fromJsonApi(xhr);
    } else if (Array.isArray(res.errors)) {
      return res.errors;
    } else {
      return [String(res.errors)];
    }
  } else {
    return fromRailsResource(xhr);
  }
};

export { fromRailsResource, fromJsonApi, fromXHR };
